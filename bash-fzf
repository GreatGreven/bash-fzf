#!/usr/bin/env bash
#########################################################################
# Script     : bash-fzf
# Author     : Eric Grevillius
# Date       : 2025-09-24
#########################################################################

##### VARIALBES #####

readarray -t ORIGINAL_INPUT
CANDIDATE_LIST_FILE="/tmp/$0.filter"
printf "%s\n" "${ORIGINAL_INPUT[@]}" > "$CANDIDATE_LIST_FILE"
QUERY_STRING=""
shopt -s checkwinsize
# this line is to ensure LINES and COLUMNS are set
(:)
DISPLAY_INTERVAL="$((LINES - 2))"
EVENT_PIPE="/tmp/$0.event.$$"
FILTER_TASK=
PRINT_TASK=
LOADING_TASK=
SELECT_INDEX="$DISPLAY_INTERVAL"

##### FUNCTIONS #####

end() {
    local exit_code="$1"
    [[ -f "$EVENT_PIPE" ]] && rm --recursive --force "$EVENT_PIPE"
    [[ -f "$CANDIDATE_LIST_FILE" ]] && rm --recursive --force "$CANDIDATE_LIST_FILE"
    unset_terminal_ui
    exit "$exit_code"
}

debug() {
    local lines=( "$@" )
    printf "%s\n" "${lines[@]}" >> debug.log
}

fatal() {
    local message="$1"
    debug "\e[31m$message\e[0m"
    printf "\e[31m%s\e[0m" "$message"
    end 2
}

set_alternate_screen_buffer() {
    printf "\e[?1049h" >&3
}

restore_normal_screen_buffer() {
    printf "\e[?1049l" >&3
}

set_scroll_margin() {
    printf "\e[H" >&3   # set cursor top left
    printf "\e[%d;%dr" "0" "$((LINES + 1))" >&3 # set scroll margin top and bottom
}

unset_scroll_margin() {
    printf "\e[H" >&3   # set cursor top left
    printf "\e[%d;%dr" "0" "$LINES" >&3 # set scroll margin top and bottom
}

stop_loading_animation() {
    if [[ -n "$LOADING_TASK" ]]; then
        kill "$LOADING_TASK"
        LOADING_TASK=
        printf "\e[%d;%dH" "$((DISPLAY_INTERVAL))" 0 >&3 # set cursor position
        printf "\e[2K" >&3 # clear line
    fi
}

loading_animation() {
    stop_loading_animation

    # start new task
    loading_animation_bg_task &
    LOADING_TASK="$!"
}

loading_animation_bg_task() {
    local frames=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")

    # Clear scroll margin
    local i
    printf "\e[H" >&3 # set cursor position
    printf "\e[?25l" >&3 # hide cursor
    for ((i=0; i < DISPLAY_INTERVAL; i++)); do
        printf "\e[2K\n" >&3
    done

    # loading animation loop
    while true; do
        for frame in "${frames[@]}"; do
            printf "\e[?25l\e[%d;%dH%s\r" "$((DISPLAY_INTERVAL))" 0 "$frame" >&3 # hide cursor, set cursor position and print frame
            read -rt 0.05 _ < /dev/zero #sleep
        done
    done
}

initiate_print_ui_bg_task() {
    # kill previous process if any
    if [[ -n "$PRINT_TASK" ]]; then
        kill "$PRINT_TASK"
        PRINT_TASK=
    fi
    # start new task
    print_ui_bg_task &
    PRINT_TASK="$!"
}

print_ui_bg_task() {
    print_ui
    echo "print-ui-done" >&4
}

print_selecter() {
    local index="$1"
    printf "\e[%d;%dH>" "$index" "0" >&3
}

unprint_selecter() {
    local index="$1"
    printf "\e[%d;%dH " "$index" "0" >&3
}

print_divider() {
    printf "\e[%d;%dH" "$((LINES - 1))" "0" >&3
    eval printf -- "%0.s=" "{1..$COLUMNS}" >&3
}

print_prompt() {
    printf "\e[?25h\e[%d;%dH > %s\e[0K" "$LINES" "0" "$QUERY_STRING" >&3 # show cursor, set position and print query string
}

print_candidate_list_in_scroll_margin() {
    local i candidate_list
    readarray -t candidate_list < "$CANDIDATE_LIST_FILE"
    local display_end="${#candidate_list[@]}"
    local blank_count=0
    local display_start="$((display_end - DISPLAY_INTERVAL ))"

    # If small list
    if [[ "$DISPLAY_INTERVAL" -ge "$display_end" ]]; then
        display_start=0
        blank_count=$((DISPLAY_INTERVAL - display_end))
    fi

    printf "\e[H" >&3
    for ((i=0; i < blank_count; i++)); do
        printf "\e[2K\n" >&3
    done
    printf "  %s\e[0K\n" "${candidate_list[@]: $display_start:$display_end}" >&3
}

print_ui() {
    print_candidate_list_in_scroll_margin
    print_selecter "$SELECT_INDEX"
    print_divider
    print_prompt
}

set_terminal_ui() {
    set_alternate_screen_buffer
    set_scroll_margin
}

unset_terminal_ui() {
    unset_scroll_margin
    restore_normal_screen_buffer
}

filter() {
    # kill previous process if any
    if [[ -n "$FILTER_TASK" ]]; then
        kill "$FILTER_TASK"
        FILTER_TASK=
    fi
    # start new task
    filter_bg_task &
    FILTER_TASK="$!"
}

filter_bg_task() {
    local candidate_list

    echo "set-loading" >&4

    for line in "${ORIGINAL_INPUT[@]}"; do
        if [[ "$line" =~ $QUERY_STRING ]]; then
            candidate_list+=( "$line" )
        fi
    done
    printf "%s\n" "${candidate_list[@]}" > "$CANDIDATE_LIST_FILE"
    echo "query-done" >&4
}

strip_last_word() {
    local words word_count
    read -ra words <<< "$@"
    word_count="${#words[@]}"
    echo "${words[@]:0:$word_count-1}"
}

read_keyboard_event_task() {
    local escape=$'\e'
    local linefeed=$'\n'
    local space=$'\u20'
    local backspace=$'\b'
    local delete=$'\u7f'
    local tab=$'\t'
    local end_of_transition_block=$'\u17'

    while true; do
        local data='' output=''
        read -rsN1 data 2>/dev/null || return
        # echo "data: $data" >&3
        # printf "%s" "$data" | xxd >&3
        case "$data" in
            "$escape")
                read -rsn2 data 2>/dev/null || return
                # echo "data2: $data" >&3
                # printf "%s" "$data" | xxd >&3
                case "$data" in
                    '[A') output="key-up";;
                    '[B') output="key-down";;
                    '[3') # delete key?
                        read -rsn1 data 2>/dev/null
                        [[ "$data" == "~" ]] && output="key-delete"
                        ;;
                esac
                ;;
            "$linefeed") output="key-enter";;
            "$space") output="key-space";;
            "$backspace"|"$delete") output="key-backspace";;
            "$end_of_transition_block") output="key-backspace-block";;
            "$tab") output="key-tab";;
            *) output="key-char $data";;
        esac
        if [[ -n "$output" ]]; then
            echo "$output"
        fi
    done
}

main () {
    ##### INITIALIZATION #####
    trap "end 1" INT TERM EXIT
    exec 3<> "$TTY" || fatal "No Terminal detected"
    mkfifo "$EVENT_PIPE" || fatal "Failed to create pipe: $EVENT_PIPE"
    exec 4<> "$EVENT_PIPE" || fatal "Failed to open pipe: $EVENT_PIPE"
    set_terminal_ui

    print_ui
    read_keyboard_event_task <&3 >&4 &

    while read -r event args; do
        # echo "event: $event, args: $args"
        case "$event" in
            "key-enter")        # pick selected
                ;;
            "key-up")           # move up selected
                line_count="$(wc -l < "$CANDIDATE_LIST_FILE")"
                [[ "$SELECT_INDEX" -gt 0 ]] \
                    && (( SELECT_INDEX > DISPLAY_INTERVAL - line_count + 1 )) \
                    && unprint_selecter "$SELECT_INDEX" \
                    && ((SELECT_INDEX--))
                ;;
            "key-down")         # move down selector
                [[ "$SELECT_INDEX" -lt "$DISPLAY_INTERVAL" ]] \
                    && unprint_selecter "$SELECT_INDEX" \
                    && ((SELECT_INDEX++))
                ;;
            "key-tab")          # don't do anything... yet
                ;;
            "key-backspace")    # remove previous char in query string
                [[ ${#QUERY_STRING} -gt 0 ]] \
                    && { QUERY_STRING="${QUERY_STRING::-1}" \
                    || fatal "Failed to backspace on string '$QUERY_STRING'"; } \
                    && filter
                ;;
            "key-backspace-block")
                [[ ${#QUERY_STRING} -gt 0 ]] \
                    && { QUERY_STRING="$(strip_last_word "$QUERY_STRING")" \
                    || fatal "Failed to backspace-block on string '$QUERY_STRING'"; } \
                    && filter
                ;;
            "key-space")        # add space character to query string
                QUERY_STRING+=" " \
                    || fatal "Failed to add space to string '$QUERY_STRING'"
                filter
                ;;
            "key-char")         # add char to query string
                QUERY_STRING+="$args" \
                    || fatal "Failed to add chars '$args' to string '$QUERY_STRING'"
                filter
                ;;
            "query-done")       # done with search, now display them
                FILTER_TASK=
                SELECT_INDEX="$DISPLAY_INTERVAL"
                stop_loading_animation
                print_candidate_list_in_scroll_margin
                print_divider
                ;;
            "print-ui-done")
                PRINT_TASK=
                ;;
            "set-loading")
                loading_animation
                ;;
            *)
                fatal "unknown event: $event, args: $args"
                ;;
        esac
        [[ -z "$LOADING_TASK" ]] \
            && print_selecter "$SELECT_INDEX"
        print_prompt
    done <&4
}

main "$@"
